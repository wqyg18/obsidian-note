
| 类型         | 收到的内容                |
| ---------- | -------------------- |
| REP / PULL | `payload`            |
| ROUTER     | `identity + payload` |

| 对比       | REQ | DEALER |
| -------- | --- | ------ |
| 是否强制一问一答 | ✅   | ❌      |
| 是否允许并发请求 | ❌   | ✅      |
| 是否允许乱序回复 | ❌   | ✅      |
| 是否适合推理引擎 | ❌   | ✅      |
zmq相比传统socket, 内部会有自动重试, 所以在connect的时候, 并不要求已经bind,也就是完全可以先请求, 然后等待server上线

---

## ZMQ 的几大核心特点（速记版）

### 1️⃣ **消息驱动，而非字节流**

- ZMQ 传输的是 **Message（消息）**，不是 TCP 的字节流
    
- 自带消息边界（无需自己拆包 / 粘包）
    
- 非常适合 RPC、任务分发、流式结果返回
    

> 和 socket.send(bytes) 不同，ZMQ 的基本单位是“完整消息”

---

### 2️⃣ **Socket ≠ 传统 socket（是“通信模式抽象”）**

- ZMQ 的 socket **不是** TCP socket
    
- 一个 ZMQ socket：
    
    - 可以连多个 endpoint
        
    - 内部可自动负载均衡
        
    - 内部维护连接、队列、状态
        

👉 ZMQ socket = **通信模式 + 状态机 + 队列**

---

### 3️⃣ **内置多种通信模式（Pattern First）**

ZMQ 最大特色之一：**先定义通信语义，再决定拓扑**

常见模式：

- REQ / REP（同步 RPC）
    
- DEALER / ROUTER（异步 RPC，vLLM 在用）
    
- PUB / SUB（广播）
    
- PUSH / PULL（任务流水线）
    
- PAIR（一对一）
    

> 模式本身就定义了：
> 
> - 谁能先发
>     
> - 是否阻塞
>     
> - 是否一对多
>     
> - 是否乱序
>     

---

### 4️⃣ **完全异步 + 非阻塞**

- 所有 socket 都是 **异步消息队列**
    
- 发送 ≠ 对端已接收
    
- 接收 ≠ 对端刚刚发送
    

ZMQ 内部有：

- Send Queue
    
- Receive Queue
    
- IO 线程
    

👉 非常适合高并发 / 流水线 / 推理引擎

---

### 5️⃣ **自动连接管理（像“消息中间件”，但不需要 broker）**

- 自动处理：
    
    - 断线重连
        
    - 对端未启动
        
    - 延迟上线
        
- connect 可以先于 bind
    
- 不需要像 Kafka / RabbitMQ 那样的中心节点
    

> ZMQ = **去中心化的 messaging**

---

### 6️⃣ **强解耦（时间 & 空间）**

- 时间解耦：
    
    - 发送方不关心接收方是否“此刻”在线
        
- 空间解耦：
    
    - 不关心对方是谁、在哪
        

👉 非常适合：

- Engine / Client 解耦
    
- 多进程 / 多节点推理
    

---

### 7️⃣ **高性能、低延迟**

- C 实现核心（libzmq）
    
- 零拷贝（zero-copy）支持
    
- 内部 IO 线程池
    
- 常被用于：
    
    - 高频交易
        
    - 推理引擎
        
    - 分布式系统内部通信
        

---

### 8️⃣ **“协议不可见”，但“语义极强”**

- 不强制协议（JSON / Protobuf / Pickle 都行）
    
- 但 **通信语义由 socket 类型强制**
    

👉 灵活 + 不容易乱写

---

### 9️⃣ **非常适合“引擎-调度-客户端”架构**

典型适用场景：

- 推理引擎（vLLM）
    
- 调度系统
    
- Actor / Worker
    
- 流式生成（token by token）
    

---
