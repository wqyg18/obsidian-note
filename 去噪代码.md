小波变换(效果还可以)
```python
def wavelet_swt_denoise(noisy_img, wavelet='db4', level=None, noise_std=None):

    """

    使用平稳小波变换 (SWT) 进行去噪 - 解决 DWT过于激进的问题

    Args:

        noisy_img: 输入噪声图像

        wavelet: 小波基 ('db4', 'sym8' 等)

        level: 分解层数 (如果不指定，自动计算)

        noise_std: 噪声标准差 (如果已知，传入可获得最佳效果；如果未知，代码会自动估计)

    """

    # 1. 处理尺寸问题 (SWT 要求图像尺寸必须是 2^level 的倍数)

    # 我们先计算合适的 padding

    if level is None:

        level = 3  # 地震数据通常 2-3 层足矣，太深会糊

    h, w = noisy_img.shape

    # 计算需要 pad 到的尺寸 (必须能被 2^level 整除)

    factor = 2 ** level

    new_h = ((h + factor - 1) // factor) * factor

    new_w = ((w + factor - 1) // factor) * factor

    # 对称填充 (Reflect padding 减少边界效应)

    pad_width = ((0, new_h - h), (0, new_w - w))

    img_padded = np.pad(noisy_img, pad_width, mode='reflect')

  

    # 2. 执行 SWT 分解

    # start_level=0 表示从第0层开始

    coeffs = pywt.swt2(img_padded, wavelet, level=level, start_level=0)

    # 3. 阈值处理

    new_coeffs = []

    # 如果没有提供 noise_std，利用第一层的高频对角系数 (HH) 估算

    # coeffs[0] 是最高频层 (Finest scale)

    # coeffs 结构: [(cA_n, (cH_n, cV_n, cD_n)), ..., (cA_1, (cH_1, cV_1, cD_1))]

    # 注意: pywt.swt2 返回的顺序通常是从 粗 -> 细 还是 细 -> 粗 取决于版本，

    # 但 list 中通常是 [level-1, level-2, ..., 0] 或者反之，

    # 稳妥起见，我们单独对每个子带做估计。

    if noise_std is None:

        # 使用第一层 (最细尺度) 的对角细节系数估计总体噪声

        # swt2 返回的 coeffs 列表通常第一个元素是最后一层的近似和细节

        # 我们取最细那一层的 Diagonal

        # 但为简便，我们在每个子带内部都做局部自适应

        pass

  

    for i, (cA, details) in enumerate(coeffs):

        (cH, cV, cD) = details

        # 对于近似系数 (cA)，通常不做处理，或者极轻微处理

        # 这里我们完全保留 cA

        new_cA = cA

        new_details = []

        for d in [cH, cV, cD]:

            # --- BayesShrink 自适应阈值计算 ---

            # 1. 估计该子带的方差 sigma_y^2

            var_y = np.mean(d**2)

            # 2. 确定噪声方差 sigma_n^2

            # 如果外部传入了 noise_std 就用外部的，否则用 MAD 估算该子带的噪声水平

            if noise_std is not None:

                sigma_n = noise_std

            else:

                sigma_n = np.median(np.abs(d)) / 0.6745

            # 3. 估计信号方差 sigma_x = sqrt(max(var_y - sigma_n^2, 0))

            sigma_x = np.sqrt(max(var_y - sigma_n**2, 0))

            # 4. 计算 Bayes 阈值 T = sigma_n^2 / sigma_x

            if sigma_x == 0:

                threshold = np.max(np.abs(d)) # 如果全是噪声，全部杀掉

            else:

                threshold = (sigma_n**2) / sigma_x

            # --- 调节因子 ---

            # BayesShrink 理论上是最优的，但为了视觉效果（保留纹理），

            # 我们可以给阈值乘一个系数 beta (0.5 ~ 1.0)

            # 如果觉得还是有点激进，把 beta 调小 (比如 0.8)

            beta = 0.8

            final_thresh = threshold * beta

            # 应用软阈值

            new_d = soft_threshold(d, final_thresh)

            new_details.append(new_d)

        new_coeffs.append((new_cA, tuple(new_details)))

    # 4. SWT 重构

    denoised_padded = pywt.iswt2(new_coeffs, wavelet)

    # 5. 裁剪回原尺寸

    denoised = denoised_padded[:h, :w]

    return denoised
```
